/c/Users/schen17/AppData/Roaming/Microsoft/Windows/Start Menu/Programs
alias python='winpty python.exe'

---OOP:

##Class and Static Methods( Methods that belong to the class and not the instance):

class BankAccount:
    # class attribute
    bank_name = "First National Dojo"
    all_accounts = []
    def __init__(self, int_rate,balance):
        self.int_rate = int_rate
        self.balance = balance
        BankAccount.all_accounts.append(self)
    
    # class method to change the name of the bank
    @classmethod
    def change_bank_name(cls,name):
        cls.bank_name = name
    # class method to get balance of all accounts
    @classmethod
    def all_balances(cls):
        sum = 0
        # we use cls to refer to the class
        for account in cls.all_accounts:
            sum += account.balance
        return sum
		
class BankAccount:
    # ... __init__ goes here
    def with_draw(self,amount):
        # we can use the static method here to evaluate
        # if we can with draw the funds without going negative
        if BankAccount.can_withdraw(self.balance,amount):
            self.balance -= amount
        else:
            print("Insufficient Funds")
        return self    
    # static methods have no access to any attribute
    # only to what is passed into it
    @staticmethod
    def can_withdraw(balance,amount):
    	if (balance - amount) < 0:
	    return False
        else:
	    return True

##Association Between Classes:
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.account = BankAccount(int_rate=0.02, balance=0)	# added this line
		
		
##OOP -- Inheritance:

class BankAccount:
    def __init__(self, int_rate, balance=0):
        self.int_rate = int_rate
        self.balance = balance
	
	def withdraw(self, amount):
    	if (self.balance - amount) > 0:
    	    self.balance -= amount
        else:
    	    print("INSUFFICIENT FUNDS")
    	return self
		
class RetirementAccount(BankAccount):
    def __init__(self, int_rate, is_roth, balance=0):
    	super().__init__(int_rate, balance)	
        self.is_roth = is_roth	
	
	def withdraw(self, amount, is_early):
    	if is_early:
    	    amount = amount * 1.10
    	super().withdraw(amount)
    	return self
		
		
##OOP --Overriding & Polymorphism:

class Parent:
    def method_a(self):
        print("invoking PARENT method_a!")
		
class Child(Parent):
    def method_a(self):
        print("invoking CHILD method_a!")
dad = Parent()
son = Child()
dad.method_a()
son.method_a() #notice this overrides the Parent method!

# We'll use the Person class to demonstrate polymorphism
# in which multiple classes inherit from the same class but behave in different ways
class Person:
  def pay_bill(self):
      raise NotImplementedError
# Millionaire inherits from Person
class Millionaire(Person):
  def pay_bill(self):
      print("Here you go! Keep the change!")
# Grad Student also inherits from the Person class
class GradStudent(Person):
  def pay_bill(self):
      print("Can I owe you ten bucks or do the dishes?")
		

##Modules & Packages

# import the library
import urllib.request
response = urllib.request.urlopen("http://www.codingdojo.com")
html = response.read()
print(html)

##dir and help functions
##dir--look for which functions are implemented in each module by using the dir function

from my_package.subdirectory import my_functions

import my_package.test_module or from my_package import test_module


##Data Structure:

//Single list:

class SLNode:
 def __init__(self, value):
  self.value = value
  self.next = None
  
class SList:
    def __init__(self):
    	self.head = None
		
	def add_to_front(self, val):
        new_node = SLNode(val)
        current_head = self.head
        new_node.next = current_head
        self.head = new_node	# SET the list's head TO the node we created in the last step
        return self	            # return self to allow for chaining
	def print_values(self):
        runner = self.head
        while (runner != None):
            print(runner.value)
        	runner = runner.next 	# set the runner to its neighbor
            return self	            # once the loop is done, return self to allow for chaining
	def add_to_back(self, val):
        if self.head == None:	# if the list is empty
			self.add_to_front(val)	# run the add_to_front method
        	return self	# let's make sure the rest of this function doesn't happen if we add to the front
        new_node = SLNode(val)
        runner = self.head
        while (runner.next != None):
            runner = runner.next
            runner.next = new_node	# increment the runner to the next node in the list
        return self                 # return self to allow for chaining

##Lambdasï¼š

##Unittest and Assertions(TDD)

# import the python testing framework
import unittest
# our "unit"
# this is what we are running our test on
def isEven(n):
    if n % 2 == 0:
       return True
    else:
       return False
# our "unit tests"
# initialized by creating a class that inherits from unittest.TestCase
class IsEvenTests(unittest.TestCase):
    # each method in this class is a test to be run
    def testTwo(self):
        self.assertEqual(isEven(2), True)
        # another way to write above is
        self.assertTrue(isEven(2))
    def testThree(self):
        self.assertEqual(isEven(3), False)
        # another way to write above is
        self.assertFalse(isEven(3))
    # any task you want run before any method above is executed, put them in the setUp method
    def setUp(self):
        # add the setUp tasks
        print("running setUp")
    # any task you want run after the tests are executed, put them in the tearDown method
    def tearDown(self):
        # add the tearDown tasks
        print("running tearDown tasks")
if __name__ == '__main__':
    unittest.main() # this runs our tests


##Flask:

##Installing our Virtual Environment tool:

pip install pipenv

pipenv install flask
##if doesn't work, use alternative:

python -m pipenv <command to use>

##Activating our Virtual Environment:
pipenv shell


##Rendering Data on a Template: (https://jinja.palletsprojects.com/en/master/templates/)

{{ some variable }}
{% some expression %}
{# ... #} for Comments not included in the template output

<!-- based on the folder structure on the right -->
<!-- linking a css style sheet -->
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='my_style.css') }}">
<!-- linking a javascript file -->
<script type="text/javascript" src="{{ url_for('static', filename='my_script.js') }}"></script>
<!-- linking an image -->
<img src="{{ url_for('static', filename='my_img.png') }}">

--or 

<!-- linking a css style sheet -->
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/my_style.css') }}">
<!-- linking a javascript file -->
<script type="text/javascript" src="{{ url_for('static', filename='js/my_script.js') }}"></script>
<!-- linking an image -->
<img src="{{ url_for('static', filename='img/my_img.png') }}">





